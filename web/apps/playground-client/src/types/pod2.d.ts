/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

export type PodId = string;
/**
 * Type encapsulating statements with their associated arguments.
 */
export type Statement =
  | {
      predicate: "None";
    }
  | {
      predicate: "ValueOf";
      /**
       * @minItems 2
       * @maxItems 2
       */
      args: [AnchoredKey, Value];
    }
  | {
      predicate: "Equal";
      /**
       * @minItems 2
       * @maxItems 2
       */
      args: [AnchoredKey, AnchoredKey];
    }
  | {
      predicate: "NotEqual";
      /**
       * @minItems 2
       * @maxItems 2
       */
      args: [AnchoredKey, AnchoredKey];
    }
  | {
      predicate: "LtEq";
      /**
       * @minItems 2
       * @maxItems 2
       */
      args: [AnchoredKey, AnchoredKey];
    }
  | {
      predicate: "Lt";
      /**
       * @minItems 2
       * @maxItems 2
       */
      args: [AnchoredKey, AnchoredKey];
    }
  | {
      predicate: "Contains";
      /**
       * @minItems 3
       * @maxItems 3
       */
      args: [AnchoredKey, AnchoredKey, AnchoredKey];
    }
  | {
      predicate: "NotContains";
      /**
       * @minItems 2
       * @maxItems 2
       */
      args: [AnchoredKey, AnchoredKey];
    }
  | {
      predicate: "SumOf";
      /**
       * @minItems 3
       * @maxItems 3
       */
      args: [AnchoredKey, AnchoredKey, AnchoredKey];
    }
  | {
      predicate: "ProductOf";
      /**
       * @minItems 3
       * @maxItems 3
       */
      args: [AnchoredKey, AnchoredKey, AnchoredKey];
    }
  | {
      predicate: "MaxOf";
      /**
       * @minItems 3
       * @maxItems 3
       */
      args: [AnchoredKey, AnchoredKey, AnchoredKey];
    }
  | {
      predicate: "HashOf";
      /**
       * @minItems 3
       * @maxItems 3
       */
      args: [AnchoredKey, AnchoredKey, AnchoredKey];
    }
  | {
      predicate: "Custom";
      /**
       * @minItems 2
       * @maxItems 2
       */
      args: [CustomPredicateRef, WildcardValue[]];
    };
export type Key = string;
/**
 * Represents various POD value types. Array, String, and Bool variants are represented untagged in JSON.
 */
export type Value =
  | {
      Set: Set;
    }
  | {
      Dictionary: Dictionary;
    }
  | {
      /**
       * An i64 represented as a string.
       */
      Int: string;
    }
  | {
      Raw: RawValue;
    }
  | Array
  | string
  | boolean;
export type Set = Value[];
export type RawValue = string;
export type Array = Value[];
export type Predicate =
  | {
      type: "Native";
      value: NativePredicate;
    }
  | {
      type: "BatchSelf";
      value: number;
    }
  | {
      type: "Custom";
      value: CustomPredicateRef;
    };
export type NativePredicate =
  | "None"
  | "ValueOf"
  | "Equal"
  | "NotEqual"
  | "LtEq"
  | "Lt"
  | "Contains"
  | "NotContains"
  | "SumOf"
  | "ProductOf"
  | "MaxOf"
  | "HashOf"
  | "DictContains"
  | "DictNotContains"
  | "SetContains"
  | "SetNotContains"
  | "ArrayContains"
  | "GtEq"
  | "Gt";
export type StatementTmplArg =
  | {
      type: "None";
    }
  | {
      type: "Literal";
      value: Value;
    }
  | {
      type: "Key";
      /**
       * @minItems 2
       * @maxItems 2
       */
      value: [Wildcard, KeyOrWildcard];
    }
  | {
      type: "WildcardLiteral";
      value: Wildcard;
    };
export type KeyOrWildcard =
  | {
      type: "Key";
      value: Key;
    }
  | {
      type: "Wildcard";
      value: Wildcard;
    };
export type WildcardValue =
  | {
      PodId: PodId;
    }
  | {
      Key: Key;
    };
export type MainPodType = "Main" | "MockMain";
export type SignedPodType = "Signed" | "MockSigned";
export type PodData =
  | {
      pod_data_variant: "Signed";
      pod_data_payload: SignedPod;
    }
  | {
      pod_data_variant: "Main";
      pod_data_payload: MainPod;
    };

export interface SchemaContainer {
  mainpod: MainPod;
  signedpod: SignedPod;
  space_info: SpaceInfo;
  pod_info: PodInfo;
}
export interface MainPod {
  id: PodId;
  publicStatements: Statement[];
  proof: string;
  params: Params;
  podType: MainPodType;
}
export interface AnchoredKey {
  podId: PodId;
  key: Key;
}
export interface Dictionary {
  [k: string]: Value;
}
export interface CustomPredicateRef {
  batch: CustomPredicateBatch;
  index: number;
}
export interface CustomPredicateBatch {
  name: string;
  predicates: CustomPredicate[];
}
/**
 * NOTE: fields are not public (outside of crate) to enforce the struct instantiation through the `::and/or` methods, which performs checks on the values.
 */
export interface CustomPredicate {
  name: string;
  /**
   * true for "and", false for "or"
   */
  conjunction: boolean;
  statements: StatementTmpl[];
  argsLen: number;
}
/**
 * Statement Template for a Custom Predicate
 */
export interface StatementTmpl {
  pred: Predicate;
  args: StatementTmplArg[];
}
export interface Wildcard {
  name: string;
  index: number;
}
export interface Params {
  maxInputSignedPods: number;
  maxInputMainPods: number;
  maxStatements: number;
  maxSignedPodValues: number;
  maxPublicStatements: number;
  maxStatementArgs: number;
  maxOperationArgs: number;
  maxCustomPredicateArity: number;
  maxCustomPredicateWildcards: number;
  maxCustomBatchSize: number;
  maxMerkleProofs: number;
  maxDepthMtGadget: number;
}
export interface SignedPod {
  id: PodId;
  entries: {
    [k: string]: Value;
  };
  proof: string;
  podType: SignedPodType;
}
export interface SpaceInfo {
  id: string;
  created_at: string;
}
export interface PodInfo {
  id: string;
  pod_type: string;
  data: PodData;
  label?: string | null;
  created_at: string;
  space: string;
}

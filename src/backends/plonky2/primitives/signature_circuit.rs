//! This file implements the Plonky2 circuit which verifies the Falcon signatures
//! (https://falcon-sign.info). Compatible with the signatures generated by signature.rs.
//!

use anyhow::Result;
use plonky2::{
    field::types::{Field, Field64},
    hash::{
        hash_types::{HashOut, HashOutTarget},
        hashing::PlonkyPermutation,
        poseidon::{Poseidon, PoseidonHash, PoseidonPermutation},
    },
    iop::{
        target::{BoolTarget, Target},
        witness::{PartialWitness, WitnessWrite},
    },
    plonk::{
        circuit_builder::CircuitBuilder,
        circuit_data::{
            CircuitConfig, CircuitData, ProverCircuitData, VerifierCircuitData,
            VerifierCircuitTarget,
        },
        config::{AlgebraicHasher, Hasher},
        proof::{ProofWithPublicInputs, ProofWithPublicInputsTarget},
    },
};

use crate::backends::plonky2::{
    basetypes::{Hash, Proof, Value, C, D, EMPTY_HASH, EMPTY_VALUE, F, VALUE_SIZE},
    circuits::common::ValueTarget,
    primitives::falcon::{
        hash_to_point::RATE_RANGE, FALCON_ENCODING_BITS, MODULUS, N, NONCE_ELEMENTS,
    },
};

// MAX_H < floor( |F| / p )
const MAX_H: u64 = F::ORDER / MODULUS as u64; // TODO review that is floor(F::O/M)
const FALCON_ENCODING_BITS_usize: usize = FALCON_ENCODING_BITS as usize;

/// An element in the Falcon-512 field, ie. modulus 12289.
#[derive(Debug, Copy, Clone)]
pub struct FalconTarget(Target);
impl FalconTarget {
    /// Checks that r = x%p, and it takes 11 plonky2 gates.
    // That is, want: r = v % p (where p is the Falcon prime)
    // thus, it exists h s.th. v = h * p + r.
    // h is the 'hint' feeded as witness.
    // Range checks:
    // i) r < p
    // ii) h < floor(|F|/p) (|F|=Goldilocks prime)
    pub fn modulus(builder: &mut CircuitBuilder<F, D>, v: Target, h: Target, r: Target) {
        let p = builder.constant(F::from_canonical_u64(MODULUS as u64));
        let computed_v = builder.mul_add(h, p, r);
        builder.connect(v, computed_v);

        // i) r < p
        assert_less::<FALCON_ENCODING_BITS_usize>(builder, r, p);
        // ii) h < MAX_H
        let max_h = builder.constant(F::from_canonical_u64(MAX_H));
        assert_less::<{ F::BITS }>(builder, h, max_h);
    }
}

// TODO move it to backends/plonky2/circuit/common.rs (not yet to avoid git-conflicts)
/// assert x<y
pub fn assert_less<const NUM_BITS: usize>(
    builder: &mut CircuitBuilder<F, D>,
    x: Target,
    y: Target,
) {
    // Check that targets fit within `NUM_BITS` bits.
    builder.range_check(x, NUM_BITS);
    builder.range_check(y, NUM_BITS);
    // Check that `y-(x+1)` fits within `NUM_BITS` bits.
    let x_plus_1 = builder.add_const(x, F::ONE);
    let expr = builder.sub(y, x_plus_1);
    builder.range_check(expr, NUM_BITS);
}

#[cfg(test)]
pub mod tests {
    use std::ops::Div;

    use plonky2::{
        field::types::Field,
        hash::{
            hash_types::{HashOut, HashOutTarget},
            poseidon::PoseidonHash,
        },
        iop::{
            target::{BoolTarget, Target},
            witness::{PartialWitness, WitnessWrite},
        },
        plonk::{
            circuit_builder::CircuitBuilder,
            circuit_data::{
                CircuitConfig, CircuitData, ProverCircuitData, VerifierCircuitData,
                VerifierCircuitTarget,
            },
            config::Hasher,
            proof::{ProofWithPublicInputs, ProofWithPublicInputsTarget},
        },
    };
    use rand::{rng, rngs::StdRng, Rng, RngCore, SeedableRng};

    use super::*;
    use crate::backends::plonky2::{
        basetypes::{Hash, F},
        circuits::common::CircuitBuilderPod,
        primitives::{
            falcon::{hash_to_point::hash_to_point, Nonce, SIG_NONCE_LEN},
            signature_proofbased::SecretKey,
        },
    };

    #[test]
    fn test_modulus() -> Result<()> {
        let p: F = F::from_canonical_u64(MODULUS as u64);
        let v: F = F::from_canonical_u64(p.0 * 42 + 3 as u64); // overflows p
        let r = F::from_canonical_u64(v.0 % p.0 as u64);
        let h = (v - r).div(p);
        assert_eq!(v, h * p + r);

        dbg!(&v);
        dbg!(&r);
        dbg!(&h);

        let config = CircuitConfig::standard_recursion_zk_config();
        let mut builder = CircuitBuilder::<F, D>::new(config);
        let mut pw = PartialWitness::<F>::new();

        let v_targ = builder.add_virtual_target();
        pw.set_target(v_targ, v)?;
        let h_targ = builder.add_virtual_target();
        pw.set_target(h_targ, h)?;
        let r_targ = builder.add_virtual_target();
        pw.set_target(r_targ, r)?;

        FalconTarget::modulus(&mut builder, v_targ, h_targ, r_targ);
        // dbg!(builder.num_gates());

        // generate & verify proof
        let data = builder.build::<C>();
        let proof = data.prove(pw)?;
        data.verify(proof.clone())?;

        Ok(())
    }
}
